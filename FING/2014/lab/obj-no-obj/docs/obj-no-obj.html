<!DOCTYPE html>

<html>
<head>
  <title>Object-Oriented programming without objects</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="object-oriented-programming-without-objects">Object-Oriented programming without objects</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>In this project, you will build the principles of
object-orientation without using a single object.</p>
<p>The purpose of this is two-fold.  First, it shows that higher-order
functions and lexical closures are expressive enough to simulate an
object-oriented language.</p>
<p>Secondly, it reveals that object concepts like method call, dynamic
dispatch, methods table and self reference are really not magical.</p>
<h3 id="before-you-begin">Before you begin</h3>
<p>To get the full grade, you must:</p>
<ul>
<li>Answer all the questions</li>
<li>Pass all the tests (every line ending with <code>//:</code> should read <code>true</code>).</li>
<li>Have no linting error.</li>
</ul>
<p><strong>Do not change any of the names</strong> of functions or objects defined
in this file, otherwise the tests will fail.  You are free to use
any name that make sense to you <em>inside</em> the scope of functions.</p>
<p>Use the online editor at <a href="http://fmdkdd.github.io/s3c/">http://fmdkdd.github.io/s3c/</a> to check for
linting errors.  There should not be any red cross or warning sign
in the gutter left of the line numbers.</p>
<p><strong>If your code contains a syntax error, your grade is zero</strong>.
If you have any linting error, you lose points.  If any of the test
evaluates to false, you lose points.  If you have an error in your
code that causes all the tests after that point to fail, you will
lose many points.</p>
<p>Your code is expected to run on Firefox 34 and above.  If you are
unsure about the behavior of your code under Firefox, write the
name and version of the web browser you used as a comment at the
start of your file.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h2 id="get-comfortable-with-closures">Get comfortable with closures</h2>
<p>To start with, let’s review closures.</p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>We’ve seen the adder, which takes a first argument and returns a
closure on <code>x</code> which takes a second argument <code>y</code> and return the sum
of <code>x</code> and <code>y</code>.  We use the term “closures” because we say that the
<code>add2</code> <em>closes</em> over its argument <code>x</code>.  <strong>Complete</strong> this
definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span><span class="hljs-params">(x)</span> </span>{

}

<span class="hljs-keyword">var</span> add2 = adder(<span class="hljs-number">2</span>);
<span class="hljs-keyword">typeof</span> add2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
add2(<span class="hljs-number">8</span>) === <span class="hljs-number">10</span>; <span class="hljs-comment">//:</span>
add2(-<span class="hljs-number">2</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We can view <code>x</code> as part of the <em>state</em> of the returned function
<code>add2</code>.  It is even more clear when using <em>mutable state</em> in the
closure, as in the <code>counter</code>.</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>The function <code>counter</code> holds an internal value (starting at 0) and
returns a function which increases and returns its internal value
when called.  <strong>Complete</strong> its definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">counter</span><span class="hljs-params">()</span> </span>{

}

<span class="hljs-keyword">var</span> c1 = counter();
<span class="hljs-keyword">typeof</span> c1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1() === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c1() === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>

<span class="hljs-keyword">var</span> c2 = counter(); <span class="hljs-comment">//:</span>
<span class="hljs-keyword">typeof</span> c2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1 !== c2; <span class="hljs-comment">//:</span>
c2() === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c2() === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>What if we want to be able to increase or decrease the counter?  We
can only return one function, but we can accept a ‘message’
argument that will differentiate the cases of increasing and
decreasing the counter.  <strong>Write</strong> the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bidiCounter</span><span class="hljs-params">()</span> </span>{

}

c1 = bidiCounter();
<span class="hljs-keyword">typeof</span> c1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'dec'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>

c2 = bidiCounter();
<span class="hljs-keyword">typeof</span> c2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1 !== c2; <span class="hljs-comment">//:</span>
c2(<span class="hljs-string">'dec'</span>) === -<span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c2(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>When we think about it, the <code>c1</code> function begins to look like an
object.  It has a state, <code>x</code>, and it has ways of executing
different behavior depending on the message given.</p>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h2 id="another-example-stack">Another example: stack</h2>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Let’s try another example: a stack ‘object’.</p>
<p>A stack must understand 4 messages:</p>
<ol>
<li>‘push’, which pushes an item on top of the stack;</li>
<li>‘pop’, which removes the item at the top of the stack and
returns it;</li>
<li>‘peek’ which returns the item at the top of the stack (but does
not remove it);</li>
<li>‘size’ which returns the number of elements in the stack.</li>
</ol>
<p>In addition, it must return the string “Message not understood”
when the message argument is not in this list.  <strong>Write</strong> this
function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stack</span><span class="hljs-params">()</span> </span>{

}

<span class="hljs-keyword">var</span> s = stack();
<span class="hljs-keyword">typeof</span> s === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
s(<span class="hljs-string">'push'</span>, <span class="hljs-number">1</span>);
s(<span class="hljs-string">'push'</span>, <span class="hljs-number">2</span>);
s(<span class="hljs-string">'push'</span>, <span class="hljs-number">3</span>);
s(<span class="hljs-string">'size'</span>) === <span class="hljs-number">3</span>; <span class="hljs-comment">//:</span>
s(<span class="hljs-string">'pop'</span>) === <span class="hljs-number">3</span>; <span class="hljs-comment">//:</span>
s(<span class="hljs-string">'peek'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
s(<span class="hljs-string">'size'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
s(<span class="hljs-string">'poke'</span>) === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span>

<span class="hljs-keyword">var</span> s2 = stack();
<span class="hljs-keyword">typeof</span> s2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
s !== s2; <span class="hljs-comment">//:</span>
s2(<span class="hljs-string">'size'</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h2 id="dynamic-dispatch">Dynamic dispatch</h2>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Let’s build another collection.  This time a queue, a first-in,
first-out collection.</p>
<p>The <code>queue</code> function creates a queue which responds to the
following messages:</p>
<ol>
<li>‘enqueue’ takes an argument and adds this element to the end of
the queue;</li>
<li>‘dequeue’ removes and returns the first element of the queue;</li>
<li>‘size’ returns the number of elements in the queue.</li>
</ol>
<p><strong>Complete</strong> the definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>{

}

<span class="hljs-keyword">var</span> q = queue();
<span class="hljs-keyword">typeof</span> q === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
q(<span class="hljs-string">'enqueue'</span>, <span class="hljs-number">1</span>);
q(<span class="hljs-string">'enqueue'</span>, <span class="hljs-number">2</span>);
q(<span class="hljs-string">'enqueue'</span>, <span class="hljs-number">3</span>);
q(<span class="hljs-string">'size'</span>) === <span class="hljs-number">3</span>; <span class="hljs-comment">//:</span>
q(<span class="hljs-string">'dequeue'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
q(<span class="hljs-string">'dequeue'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
q(<span class="hljs-string">'q'</span>) === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span>

<span class="hljs-keyword">var</span> q2 = queue();
<span class="hljs-keyword">typeof</span> q2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
q !== q2; <span class="hljs-comment">//:</span>
q2(<span class="hljs-string">'size'</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Now we can write a generic function size that retrieves the size of
the collection.  All that matters is that the object passed as an
argument to this function understands the ‘size’ message, and
returns a meaningful value.  <strong>Complete</strong> the definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectionSize</span><span class="hljs-params">(collection)</span> </span>{

}

collectionSize(s) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
collectionSize(q) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
collectionSize(stack()) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span>
collectionSize(queue()) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h2 id="a-simple-point-object">A simple point object</h2>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Another example of abstraction with objects is a 1-dimensional
point.</p>
<p>The <code>point</code> function takes one argument: the initial value for the
x coordinate of the point, and returns a function that understands
the following messages:</p>
<ol>
<li>‘getX’: returns the value of the x coordinate;</li>
<li>‘setX’: takes an argument and sets the x coordinate of the point
to the argument value;</li>
<li>‘equals’: takes another point as argument, and returns true if
and only if both points have the same coordinates.</li>
</ol>
<p><strong>Complete</strong> the definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point</span><span class="hljs-params">(x)</span> </span>{

}

<span class="hljs-keyword">var</span> p1 = point(<span class="hljs-number">0</span>);
<span class="hljs-keyword">typeof</span> p1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
<span class="hljs-keyword">var</span> p2 = point(<span class="hljs-number">1</span>);
<span class="hljs-keyword">typeof</span> p2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p1 !== p2; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p2) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p1) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'setX'</span>, <span class="hljs-number">1</span>);
p1(<span class="hljs-string">'equals'</span>, p2); <span class="hljs-comment">//:</span>
p1() === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h2 id="self-reference">Self reference</h2>

            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Let’s add another method to the point object, the method
‘rightmost’ which takes another point as argument and returns the
point with the higher x coordinate.  What value should we return
for the current object?</p>
<p>We have no way to refer to the object itself inside its methods!
The object itself is what is returned by the function <code>point</code>.</p>
<p><strong>Complete</strong> this definition.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">point2</span><span class="hljs-params">(x)</span> </span>{

}

p1 = point2(<span class="hljs-number">1</span>);
<span class="hljs-keyword">typeof</span> p1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p2 = point2(<span class="hljs-number">0</span>);
<span class="hljs-keyword">typeof</span> p2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p1 !== p2; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'rightmost'</span>, p2) === p1; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'rightmost'</span>, p1) === p1; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p2) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p1) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'setX'</span>, <span class="hljs-number">2</span>);
p1(<span class="hljs-string">'rightmost'</span>, p2) === p2; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'rightmost'</span>, p1) === p2; <span class="hljs-comment">//:</span>
p1() === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2 id="abstracting-the-object-pattern">Abstracting the object pattern</h2>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>All these object definitions are frankly getting a little
repetitive.  Once we have seen the pattern, the methods objects is
always defined in the same way, and the returned function is always
the same.</p>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>We can abstract the pattern by creating an <code>object</code> function, which
takes the methods of the object to create, and return the
dispatching function.  <strong>Write</strong> this function.  An example of its
use follows.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span><span class="hljs-params">(methods)</span> </span>{

}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Here is how we use <code>object</code> to create the bi-directional counter at
the beginning of this document.  Note that we are using a
JavaScript object, but only as a dictionary structure.  We could
have used an array of tuples as well, or a Map.  The literal object
syntax is just more convenient.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

 <span class="hljs-keyword">return</span> object({
   inc: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
     i += <span class="hljs-number">1</span>;
     <span class="hljs-keyword">return</span> i;
   },

   dec: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
     i -= <span class="hljs-number">1</span>;
     <span class="hljs-keyword">return</span> i;
   },
 });
}

c1 = makeCounter();
<span class="hljs-keyword">typeof</span> c1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
c1(<span class="hljs-string">'dec'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c1() === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span>

c2 = makeCounter();
<span class="hljs-keyword">typeof</span> c2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
c1 !== c2; <span class="hljs-comment">//:</span>
c2(<span class="hljs-string">'dec'</span>) === -<span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
c2(<span class="hljs-string">'inc'</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">//:</span>
c2(<span class="hljs-string">'ee'</span>) === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h2 id="self-reference-again">Self-reference, again</h2>

            </div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>If we want to define a <code>point2</code> object with <code>object</code>, we need to to
pass the object itself to the methods in the dispatcher.  Let’s
call this variant <code>objectWithSelf</code>.  <strong>Complete</strong> its definition.
Look at an example of its use in <code>makePoint</code> below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectWithSelf</span><span class="hljs-params">(methods)</span> </span>{

}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>This defines a <code>point2</code> object with <code>objectWithSelf</code>.  Note how the
methods receive the object itself as first argument: we can call
methods on <code>self</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePoint</span><span class="hljs-params">(x)</span> </span>{
  <span class="hljs-keyword">return</span> objectWithSelf({
    getX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> x;
    },

    setX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, v)</span> </span>{
      x = v;
    },

    equals: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, p)</span> </span>{
      <span class="hljs-keyword">return</span> p(<span class="hljs-string">'getX'</span>) === self(<span class="hljs-string">'getX'</span>);
    },

    rightmost: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, p)</span> </span>{
      <span class="hljs-keyword">return</span> self(<span class="hljs-string">'getX'</span>) &gt; p(<span class="hljs-string">'getX'</span>) ? self : p;
    },
  });
}

p1 = makePoint(<span class="hljs-number">1</span>);
<span class="hljs-keyword">typeof</span> p1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p2 = makePoint(<span class="hljs-number">0</span>);
<span class="hljs-keyword">typeof</span> p2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p1 !== p2; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'rightmost'</span>, p2) === p1; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'rightmost'</span>, p1) === p1; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'setX'</span>, <span class="hljs-number">2</span>);
p1(<span class="hljs-string">'rightmost'</span>, p2) === p2; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'rightmost'</span>, p1) === p2; <span class="hljs-comment">//:</span>
p1() === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="forwarding">Forwarding</h2>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Let’s say we want to define a two-dimensional point.  Since we
already have a one-dimensional one, we would like to reuse its
functionality for the x coordinate.  We can define this object
using <code>objectWithSelf</code> and <code>makePoint</code>.  We’ll leave the
<code>rightmost</code> method for later, as it will prove problematic.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePoint2d</span><span class="hljs-params">(x,y)</span> </span>{
  <span class="hljs-keyword">var</span> point1d = makePoint(x);

  <span class="hljs-keyword">return</span> objectWithSelf({
    getX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> point1d(<span class="hljs-string">'getX'</span>);
    },

    setX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, v)</span> </span>{
      point1d(<span class="hljs-string">'setX'</span>, v);
    },

    getY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> y;
    },

    setY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, v)</span> </span>{
      y = v;
    },

    equals: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, p)</span> </span>{
      <span class="hljs-keyword">return</span> point1d(<span class="hljs-string">'equals'</span>, p) &amp;&amp; p(<span class="hljs-string">'getY'</span>) === self(<span class="hljs-string">'getY'</span>);
    },
  });
}</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><strong>Check</strong> that all these tests return <code>true</code>, otherwise you made a
mistake in <code>objectWithSelf</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>p1 = makePoint2d(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">typeof</span> p1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p2 = makePoint2d(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);
<span class="hljs-keyword">typeof</span> p2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p1 !== p2; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'getY'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">3</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'getY'</span>) === <span class="hljs-number">5</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p2) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'setX'</span>, <span class="hljs-number">3</span>);
p1(<span class="hljs-string">'setY'</span>, <span class="hljs-number">5</span>);
p1(<span class="hljs-string">'equals'</span>, p2); <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p1); <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p1); <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p2); <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>We have effectively forwarded the messages we did not want to
handle on the internal <code>point1d</code>.  Though we have to be exhaustive
in <code>makePoint2d</code>: every message that we want to forward must be
explicitly specified as such.</p>

            </div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h2 id="delegation">Delegation</h2>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>What if we could define a handler object for all messages we do not
wish to capture?  That would save us from explicitly forwarding all
messages.</p>

            </div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>The <code>objectWithDelegate</code> function takes an additional argument, the
<code>delegate</code> object, and when the method is not found in the current
object, it lets the delegate object try to answer it.  <strong>Write</strong>
this function.  You should also add the delegate in a property
named <code>delegate</code> to the returned function, in order for <code>equals</code> to
work in the example below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectWithDelegate</span><span class="hljs-params">(methods, delegate)</span> </span>{

}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Here is how we use it.  Note the additional argument to
<code>objectWithDelegate</code>.  Also note the <code>self.delegate</code> in <code>equals</code> to
refer to the delegate object from inside the methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePoint2dDelegated</span><span class="hljs-params">(x, y)</span> </span>{
  <span class="hljs-keyword">return</span> objectWithDelegate({
    getY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> y;
    },

    setY: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, v)</span> </span>{
      y = v;
    },

    equals: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, p)</span> </span>{
      <span class="hljs-keyword">return</span> self.delegate(<span class="hljs-string">'equals'</span>, p) &amp;&amp; p(<span class="hljs-string">'getY'</span>) === self(<span class="hljs-string">'getY'</span>);
    },
  }, makePoint(x));
}

p1 = makePoint2dDelegated(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">typeof</span> p1 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p2 = makePoint2dDelegated(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);
<span class="hljs-keyword">typeof</span> p2 === <span class="hljs-string">'function'</span>; <span class="hljs-comment">//:</span>
p1 !== p2; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">1</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'getY'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'getX'</span>) === <span class="hljs-number">3</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'getY'</span>) === <span class="hljs-number">5</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p2) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p1) === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'setX'</span>, <span class="hljs-number">3</span>);
p1(<span class="hljs-string">'setY'</span>, <span class="hljs-number">5</span>);
p1(<span class="hljs-string">'equals'</span>, p2); <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p1); <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'equals'</span>, p1); <span class="hljs-comment">//:</span>
p2(<span class="hljs-string">'equals'</span>, p2); <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h2 id="fixing-the-self">Fixing the self</h2>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Why does the call to ‘rightmost’ fail?  To make things worse, note
that inverting the points gives a different answer, even though
‘rightmost’ is obviously a symmetric operation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>p1 = makePoint2dDelegated(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
p2 = makePoint2dDelegated(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);
p2(<span class="hljs-string">'rightmost'</span>, p1) === p2 === <span class="hljs-literal">false</span>; <span class="hljs-comment">//:</span>
p1(<span class="hljs-string">'rightmost'</span>, p2) === p2 === <span class="hljs-literal">true</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Well, it has to do with the binding of the <code>self</code> variable.  Recall
that <code>rightmost</code> returns <code>self</code>, but since <code>rightmost</code> is called
from a 1-dimensional point, <code>self</code> in this refers to the
1-dimensional point object.  In the current case, we expect <code>self</code>
to refer to the <em>receiver</em> of the ‘rightmost’ message, not the
object that actually responded to it.</p>

            </div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>To fix this issue, we need to pass to each method the reference of
the actual receiver.  But where does this receiver value come from?
It is provided by the original caller of the method, so it must be
passed as an argument to the dispatcher.  <strong>Write</strong> the functions
<code>objectWithSelf2</code> and <code>objectWithDelegate2</code> that correctly handles
the issue with <code>rightmost</code>.  Check that they work with the example
below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectWithSelf2</span><span class="hljs-params">(methods)</span> </span>{

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectWithDelegate2</span><span class="hljs-params">(methods, delegate)</span> </span>{

}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>To check that it works, we can just create a point objects that
delegates everything to a 1-dimensional point.  We must first
define a new version of <code>makePoint</code> that handles the additional
<code>receiver</code>argument.  Note the additional arguments when calling a
method on <code>self</code> and <code>p</code> in <code>rightmost</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePointWithReceiver</span><span class="hljs-params">(x)</span> </span>{
  <span class="hljs-keyword">return</span> objectWithSelf2({
    getX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> x; },
    setX: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, v)</span> </span>{ x = v; },
    rightmost: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, p)</span> </span>{ <span class="hljs-keyword">return</span> self(self, <span class="hljs-string">'getX'</span>) &gt; p(p, <span class="hljs-string">'getX'</span>) ? self : p; },
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makePointDelegated</span><span class="hljs-params">(x)</span> </span>{
  <span class="hljs-keyword">return</span> objectWithDelegate2({}, makePointWithReceiver(x));
}

p1 = makePointDelegated(<span class="hljs-number">1</span>);
p2 = makePointDelegated(<span class="hljs-number">3</span>);
p1(p1, <span class="hljs-string">'setX'</span>, <span class="hljs-number">2</span>);
p1(p1, <span class="hljs-string">'getX'</span>) === <span class="hljs-number">2</span>; <span class="hljs-comment">//:</span>
p1(p1, <span class="hljs-string">''</span>) === <span class="hljs-string">"Message not understood"</span>; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Again, the receiver is the first argument when calling methods now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>p2(p2, <span class="hljs-string">'rightmost'</span>, p1) === p2; <span class="hljs-comment">//:</span>
p1(p1, <span class="hljs-string">'rightmost'</span>, p2) === p2; <span class="hljs-comment">//:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h2 id="getting-back-to-javascript">Getting back to JavaScript</h2>
<p>How does all of this relate to JavaScript objects?  The <code>self</code>
reference we used is called <code>this</code> in JavaScript, and <code>this</code> is an
hidden argument to functions (contrast this to methods in Python,
which receive an extra <code>self</code> argument).  The ‘delegate’ link we
defined is just the prototype link of JavaScript objects.  The
passing of the receiver object to the delegated method is exactly
the same mechanism.  There is nothing more to objects and
prototypes in JavaScript than what we’ve implemented here.</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
